<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="texturas # mezclar datos interpolados de color y texel
coloring brightness tools"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://compuvisual2023i.github.io/showcase/docs/Entregas/Shaders/Texturing/"><title>Texturing | Computación Visual 2023-I</title><link rel=manifest href=/showcase/manifest.json><link rel=icon href=/showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/showcase/flexsearch.min.js></script>
<script defer src=/showcase/en.search.min.3a8d658c77eb93c7f12a2b8af49a700131e474f288eefb605d9fa61576dbe5a7.js integrity="sha256-Oo1ljHfrk8fxKiuK9JpwATHkdPKI7vtgXZ+mFXbb5ac=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=https://compuvisual2023i.github.io/showcase/docs/Entregas/Shaders/Texturing/index.xml title="Computación Visual 2023-I"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase/><span>Computación Visual 2023-I</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/showcase/docs/Julio/>Julio</a></li><li><a href=/showcase/docs/Jhon/>Jhon</a></li><li><a href=/showcase/docs/Santiago/>Santiago</a></li><li><input type=checkbox id=section-199f820c3863c09a6d11bbcf40d35372 class=toggle checked>
<label for=section-199f820c3863c09a6d11bbcf40d35372 class="flex justify-between"><a href=/showcase/docs/Entregas/>Entregas</a></label><ul><li><input type=checkbox id=section-2ad2dee4d480516c5de1257cf349c632 class=toggle>
<label for=section-2ad2dee4d480516c5de1257cf349c632 class="flex justify-between"><a role=button>Rendering</a></label><ul><li><a href=/showcase/docs/Entregas/Rendering/Raycasting/>Raycasting</a></li></ul></li><li><input type=checkbox id=section-c13ebe2f6b2104ad5ffaadc2cf33e7b8 class=toggle checked>
<label for=section-c13ebe2f6b2104ad5ffaadc2cf33e7b8 class="flex justify-between"><a role=button>Shaders</a></label><ul><li><a href=/showcase/docs/Entregas/Shaders/coloring/>Coloring</a></li><li><a href=/showcase/docs/Entregas/Shaders/Post-Effects/>Post Effects</a><ul></ul></li><li><a href=/showcase/docs/Entregas/Shaders/Texturing/ class=active>Texturing</a><ul></ul></li></ul></li><li><input type=checkbox id=section-a9beeb45f7767fa9178e1bf3e56f8ecf class=toggle>
<label for=section-a9beeb45f7767fa9178e1bf3e56f8ecf class="flex justify-between"><a href=/showcase/docs/Entregas/Visual-Illutions/>Visual Illutions</a></label><ul><li><a href=/showcase/docs/Entregas/Visual-Illutions/App-Perlin/>App Perlin</a></li><li><a href=/showcase/docs/Entregas/Visual-Illutions/Color-Blind/>Color Blind</a><ul></ul></li><li><a href=/showcase/docs/Entregas/Visual-Illutions/Masking/>Masking</a></li><li><a href=/showcase/docs/Entregas/Visual-Illutions/Monocular-Cues/>Monocular Cues</a></li><li><a href=/showcase/docs/Entregas/Visual-Illutions/Pixelador/>Pixelador</a><ul></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Texturing</strong>
<label for=toc-control><img src=/showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#texturas>texturas</a></li></ul></nav></aside></header><article class=markdown><h1 id=texturas>texturas
<a class=anchor href=#texturas>#</a></h1><p>mezclar datos interpolados de color y texel</p><iframe id=breath style=width:600px;height:600px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script>
              
let img;
let tex;
let showTexture = false;

function preload() {
  // Carga la imagen y la textura
  img = loadImage('imagen.jpg');
  tex = loadImage('textura.jpg');
}

function setup() {
  createCanvas(500, 500);
  noLoop();

  // Crea un botón para alternar la visualización de la textura
  let toggleButton = createButton('Mostrar textura');
  toggleButton.mousePressed(toggleTexture);
  toggleButton.position(10, height + 10);
}

function draw() {
  background(0);

  if (showTexture) {
    // Dibuja la imagen modificada con la textura
    imageWithTexture();
  } else {
    // Dibuja la imagen original
    image(img, 0, 0);
  }
}

function imageWithTexture() {
  // Crea una copia de la imagen original
  let tintedImg = createImage(img.width, img.height);
  tintedImg.copy(img, 0, 0, img.width, img.height, 0, 0, img.width, img.height);

  // Obtiene los píxeles de la imagen y la textura
  img.loadPixels();
  tex.loadPixels();
  tintedImg.loadPixels();

  // Recorre todos los píxeles de la imagen
  for (let x = 0; x < img.width; x++) {
    for (let y = 0; y < img.height; y++) {
      let index = (x + y * img.width) * 4;

      // Obtiene los componentes de color del píxel de la imagen
      let r = img.pixels[index];
      let g = img.pixels[index + 1];
      let b = img.pixels[index + 2];

      // Obtiene los componentes de color del píxel de la textura
      let texX = map(x, 0, img.width, 0, tex.width);
      let texY = map(y, 0, img.height, 0, tex.height);
      let texIndex = (int(texX) + int(texY) * tex.width) * 4;
      let texR = tex.pixels[texIndex];
      let texG = tex.pixels[texIndex + 1];
      let texB = tex.pixels[texIndex + 2];

      // Mezcla los componentes de color de la imagen y la textura
      let mixedR = lerp(r, texR, 0.5);
      let mixedG = lerp(g, texG, 0.5);
      let mixedB = lerp(b, texB, 0.5);

      // Asigna los nuevos componentes de color al píxel de la imagen
      tintedImg.pixels[index] = mixedR;
      tintedImg.pixels[index + 1] = mixedG;
      tintedImg.pixels[index + 2] = mixedB;
    }
  }

  // Actualiza los cambios en la imagen modificada
  tintedImg.updatePixels();

  // Dibuja la imagen modificada
  image(tintedImg, 0, 0);
}

function toggleTexture() {
  showTexture = !showTexture;
  redraw();
}


            </script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><p>coloring brightness tools</p><iframe id=breath style=width:600px;height:600px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script>
              
let img;
let originalImg;    

function preload() {
  // Carga la imagen
  img = loadImage('imagen.jpg');
  originalImg = loadImage('imagen.jpg');
}

function setup() {
  createCanvas(500, 500);
  noLoop();

  // Crea botones para las diferentes herramientas
  let hsvButton = createButton('Valor (HSV)');
  hsvButton.mousePressed(applyHSV);
  hsvButton.position(10, height + 10);

  let hslButton = createButton('Luminosidad (HSL)');
  hslButton.mousePressed(applyHSL);
  hslButton.position(110, height + 10);

  let averageButton = createButton('Promedio de componentes');
  averageButton.mousePressed(calculateAverage);
  averageButton.position(250, height + 10);

  let resetButton = createButton('reset');
  resetButton.mousePressed(restoreImage);
  resetButton.position(440, height + 10);
}  



function draw() {
  background(0);
  image(img, 0, 0);
}

function applyHSV() {
  img.loadPixels();

  // Recorre todos los píxeles de la imagen
  for (let i = 0; i < img.pixels.length; i += 4) {
    // Convierte el color del píxel a HSV
    let hsv = rgbToHsv(img.pixels[i], img.pixels[i + 1], img.pixels[i + 2]);
    // Actualiza el valor V con el promedio de los componentes RGB
    hsv.v = (img.pixels[i] + img.pixels[i + 1] + img.pixels[i + 2]) / 3;
    // Convierte el color de nuevo a RGB y actualiza los píxeles
    let rgb = hsvToRgb(hsv.h, hsv.s, hsv.v);
    img.pixels[i] = rgb.r;
    img.pixels[i + 1] = rgb.g;
    img.pixels[i + 2] = rgb.b;
  }

  img.updatePixels();
  redraw();
}

function applyHSL() {
  img.loadPixels();

  // Recorre todos los píxeles de la imagen
  for (let i = 0; i < img.pixels.length; i += 4) {
    // Convierte el color del píxel a HSL
    let hsl = rgbToHsl(img.pixels[i], img.pixels[i + 1], img.pixels[i + 2]);
    // Actualiza la luminosidad L con el promedio de los componentes RGB
    hsl.l = (img.pixels[i] + img.pixels[i + 1] + img.pixels[i + 2]) / (3 * 255);
    // Convierte el color de nuevo a RGB y actualiza los píxeles
    let rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    img.pixels[i] = rgb.r;
    img.pixels[i + 1] = rgb.g;
    img.pixels[i + 2] = rgb.b;
  }

  img.updatePixels();
  redraw();
}

function calculateAverage() {
  img.loadPixels();

  // Calcula el promedio de los componentes RGB de la imagen
  let totalR = 0;
  let totalG = 0;
  let totalB = 0;

  // Recorre todos los píxeles de la imagen y suma los componentes RGB
  for (let i = 0; i < img.pixels.length; i += 4) {
    totalR += img.pixels[i];
    totalG += img.pixels[i + 1];
    totalB += img.pixels[i + 2];
  }

  // Calcula el promedio dividiendo por la cantidad de píxeles
  let avgR = totalR / (img.width * img.height);
  let avgG = totalG / (img.width * img.height);
  let avgB = totalB / (img.width * img.height);

  // Actualiza todos los píxeles con el promedio de los componentes
  for (let i = 0; i < img.pixels.length; i += 4) {
    img.pixels[i] = avgR;
    img.pixels[i + 1] = avgG;
    img.pixels[i + 2] = avgB;
  }

  img.updatePixels();
  redraw();
}

// Función para convertir RGB a HSV
function rgbToHsv(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;

  let max = Math.max(r, g, b);
  let min = Math.min(r, g, b);
  let h, s, v = max;

  let d = max - min;
  s = max === 0 ? 0 : d / max;

  if (max === min) {
    h = 0; // grayscale
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }

  return {
    h: h,
    s: s,
    v: v
  };
}

// Función para convertir HSV a RGB
function hsvToRgb(h, s, v) {
  let r, g, b;

  let i = Math.floor(h * 6);
  let f = h * 6 - i;
  let p = v * (1 - s);
  let q = v * (1 - f * s);
  let t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
      r = v;
      g = p;
      b = q;
      break;
  }

  return {
    r: Math.floor(r * 255),
    g: Math.floor(g * 255),
    b: Math.floor(b * 255)
  };
}

// Función para convertir RGB a HSL
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;

  let max = Math.max(r, g, b);
  let min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
    h = s = 0; // grayscale
  } else {
    let d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }

  return {
    h: h,
    s: s,
    l: l
  };
}

// Función para convertir HSL a RGB
function hslToRgb(h, s, l) {
  let r, g, b;

  if (s === 0) {
    r = g = b = l; // grayscale
  } else {
    let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    let p = 2 * l - q;

    r = hueToRgb(p, q, h + 1 / 3);
    g = hueToRgb(p, q, h);
    b = hueToRgb(p, q, h - 1 / 3);
  }

  return {
    r: Math.floor(r * 255),
    g: Math.floor(g * 255),
    b: Math.floor(b * 255)
  };
}

// Función auxiliar para calcular el componente RGB en base al valor de hue en HSL
function hueToRgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}

function restoreImage() {
  // Restaura la imagen original
  img = originalImg.get();
  redraw(); 
}


            </script>
          </head>
          <body>
          </body>
        </html>
      "></iframe></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/compuvisual2023i/showcase/commit/6b68637ec51f21154e7624232a43efd09ab201d9 title='Last modified by julio | May 18, 2023' target=_blank rel=noopener><img src=/showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>May 18, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#texturas>texturas</a></li></ul></nav></div></aside></main></body></html>